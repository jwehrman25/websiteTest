<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Robot moving in circles</title>
    <style>
        body {
            margin: 0;
        }
    </style>
</head>

<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let velocity = { x: 0, y: 0, z: 0 }
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, -20);
        camera.lookAt(0, 0, 1);

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Directional light
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 5);
        scene.add(directionalLight);

        // Point light
        const pointLight = new THREE.PointLight(0xffffff, 1);
        pointLight.position.set(0, 0, 0);

        // Ambient light
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        const robot = new THREE.Group();
        scene.add(robot);

        // Custom shader material
        const vertexShader = `
            varying vec3 vNormal;
            varying vec3 vViewPosition;

            void main() {
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                gl_Position = projectionMatrix * mvPosition;
                vNormal = normalize(normalMatrix * normal);
                vViewPosition = -mvPosition.xyz;
            }
        `;

        const fragmentShader = `
            varying vec3 vNormal;
            varying vec3 vViewPosition;

            uniform vec3 directionalLightColor;
            uniform vec3 pointLightColor;
            uniform vec3 ambientLightColor;
            uniform vec3 directionalLightPos;
            uniform vec3 pointLightPos;

            void main() {
                vec3 normal = normalize(vNormal);
                vec3 viewDir = normalize(vViewPosition);

                // Directional light
                vec3 lightDirection = normalize(directionalLightPos);
                float diffDir = max(dot(normal, -lightDirection), 0.0);

                // Point light
                vec3 lightDirPoint = normalize(pointLightPos - vViewPosition);
                float diffPoint = max(dot(normal, lightDirPoint), 0.0);

                vec3 ambient = ambientLightColor;
                vec3 diffuse = directionalLightColor * diffDir + pointLightColor * diffPoint;
                vec3 color = ambient + diffuse;

                gl_FragColor = vec4(color, 1.0);
            }
        `;

        const greyMaterial = new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            uniforms: {
                directionalLightColor: { value: directionalLight.color },
                pointLightColor: { value: pointLight.color },
                ambientLightColor: { value: ambientLight.color },
                directionalLightPos: { value: new THREE.Vector3(5, 10, 5) },
                pointLightPos: { value: new THREE.Vector3(0,0,0) },
            }
        });

        const greenMaterial = new THREE.MeshStandardMaterial({ color: 'green' });
        const cubeGeometry = new THREE.BoxGeometry();
        const cube = new THREE.Mesh(cubeGeometry, greyMaterial);
        robot.add(cube);
        
        cube.add(pointLight);
        directionalLight.target = cube;

        const cylinder = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 2, 32), greyMaterial);
        cylinder.position.y = -1.5;
        robot.add(cylinder);

        // Robot wheel
        const wheelRadius = 0.7;
        const wheelHeight = 0.3;
        const wheel = new THREE.Mesh(
            new THREE.CylinderGeometry(wheelRadius, wheelRadius, wheelHeight, 32),
            greyMaterial
        );
        wheel.position.y = -3;
        wheel.rotation.x = Math.PI / 2;
        robot.add(wheel);

        const lArmRoot = new THREE.Group();
        lArmRoot.position.z = 1.15;
        lArmRoot.position.y = -.6;
        robot.add(lArmRoot);

        const lArm = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.5, 0.3, 1), greyMaterial);
        lArm.position.y = -0.75
        lArmRoot.add(lArm);

        const rArmRoot = new THREE.Group();
        rArmRoot.position.z = -1.15;
        rArmRoot.position.y = -.6;
        robot.add(rArmRoot);

        const rArm = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.5, 0.3, 1), greyMaterial);
        rArm.position.y = -0.75
        rArmRoot.add(rArm);

        // Ground plane
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(20, 20), greenMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -4;
        scene.add(ground);

        // Mouse movement for camera
        document.addEventListener('mousedown', (event) => {
            previousMousePosition = { x: event.clientX, y: event.clientY };
        });

        document.addEventListener('mousemove', (event) => {
            if (event.buttons === 1) {
                const deltaX = event.clientX - previousMousePosition.x;
                //const deltaY = event.clientY - previousMousePosition.y;

                const sensitivity = 0.005;
                //camera.rotation.x = camera.rotation.x + (deltaY * sensitivity);
                camera.rotation.y = camera.rotation.y + (deltaX * sensitivity)

                previousMousePosition = { x: event.clientX, y: event.clientY };
            }
        });

        // Animation
        const animate = function () {
            requestAnimationFrame(animate);

            // Rotate and move the robot
            robot.rotateY(Math.sin(0.005));
            const speed = 0.02;
            robot.translateX(speed);

            lArmRoot.rotateZ(Math.sin(0.005));
            rArmRoot.rotateZ(Math.sin(-0.005));

            // Camera movement
            camera.translateX(velocity.x * 0.01);
            camera.translateY(velocity.y * 0.01);
            camera.translateZ(velocity.z * 0.01);

            renderer.render(scene, camera);
        };


        // Handle window resize
        window.addEventListener('resize', () => {
            const newWidth = window.innerWidth;
            const newHeight = window.innerHeight;

            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(newWidth, newHeight);
        });


        // Camera controls
        document.addEventListener('keydown', function (event) {
            switch (event.key) {
                case 'w':
                    velocity.z = -1;
                    break;
                case 'a':
                    velocity.x = -1;
                    break;
                case 's':
                    velocity.z = 1;
                    break;
                case 'd':
                    velocity.x = 1;
                    break;
                case 'r':
                    console.log(camera.rotation);
            }
        });

        document.addEventListener('keyup', function (event) {
            switch (event.key) {
                case 'w':
                    velocity.z = 0;
                    break;
                case 'a':
                    velocity.x = 0;
                    break;
                case 's':
                    velocity.z = 0;
                    break;
                case 'd':
                    velocity.x = 0;
                    break;
            }
        });
        animate();
    </script>
</body>

</html>
